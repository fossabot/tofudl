// Copyright (c) The OpenTofu Authors
// SPDX-License-Identifier: MPL-2.0

package main

import (
	"crypto/tls"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"

	"github.com/ProtonMail/gopenpgp/v2/crypto"
	"github.com/opentofu/tofudl/branding"
)

var templateText = `// Copyright (c) {{ .Authors }}
// SPDX-License-Identifier: {{ .License }}

// Code generated by tools/bundle-gpg-key/main.go. DO NOT EDIT.

package branding

//go:` + `generate go run github.com/opentofu/tofudl/tools/bundle-gpg-key -file {{ .File }} -url {{ .URL }}

// DefaultGPGKey holds the default GPG key bundled with the downloader. This key was downloaded from
// {{ .URL }}
const DefaultGPGKey = ` + "`{{ .GPGKey }}`\n"

type templateParams struct {
	Authors string
	License string
	File    string
	URL     string
	GPGKey  string
}

func main() {
	targetFile := "gpg_key.go"
	gpgKeyURL := branding.GPGKeyURL
	checkOnly := false

	flag.BoolVar(&checkOnly, "check-only", checkOnly, "Only check if the file contents are correct.")
	flag.StringVar(&targetFile, "file", targetFile, "Target file to write to.")
	flag.StringVar(&gpgKeyURL, "url", gpgKeyURL, "URL to download the ASCII-armored GPG key from.")
	flag.Parse()

	req, err := http.NewRequest(http.MethodGet, gpgKeyURL, nil) //nolint:noctx //This is a go:generate tool
	if err != nil {
		log.Fatalf("Failed to create HTTP request (%v)", err)
	}
	transport := http.DefaultTransport.(*http.Transport)
	transport.TLSClientConfig = &tls.Config{
		MinVersion: tls.VersionTLS13,
	}
	client := http.Client{
		Transport: transport,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return fmt.Errorf("no redirects allowed")
		},
	}

	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("Failed to send HTTP request (%v)", err)
	}
	if resp.StatusCode != http.StatusOK {
		_ = resp.Body.Close()
		log.Fatalf("Invalid status code returned: %d", resp.StatusCode)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		_ = resp.Body.Close()
		log.Fatalf("Failed to read HTTP body (%v)", err)
	}
	_ = resp.Body.Close()

	key, err := crypto.NewKeyFromArmored(string(body))
	if err != nil {
		log.Fatalf("Failed to decode downloaded key (%v).", err)
	}
	gotFingerprint := strings.ToUpper(key.GetFingerprint())
	expectedFingerprint := strings.ToUpper(branding.GPGKeyFingerprint)
	if gotFingerprint != expectedFingerprint {
		log.Fatalf(
			"Incorrect key fingerprint for downloaded key: %s (expected: %s)",
			gotFingerprint,
			expectedFingerprint,
		)
	}
	if !key.CanVerify() {
		log.Fatalf("The downloaded key is not suitable for verification.")
	}

	tpl := template.New(targetFile + ".tpl")
	tpl, err = tpl.Parse(templateText)
	if err != nil {
		log.Fatalf("Failed to parse template file (%v)", err)
	}
	tempFile := targetFile + "~"
	fh, err := os.OpenFile(tempFile, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("Failed to create temporary file %s (%v)", tempFile, err)
	}
	closeFile := func() {
		err := fh.Close()
		if err != nil {
			log.Fatalf("Failed to write temporary file %s (%v)", tempFile, err)
		}
	}
	if err := tpl.Execute(fh, templateParams{
		Authors: branding.SPDXAuthorsName,
		License: branding.SPDXLicense,
		File:    targetFile,
		URL:     gpgKeyURL,
		GPGKey:  string(body),
	}); err != nil {
		closeFile()
		log.Fatalf("Failed to execute template (%v)", err)
	}
	closeFile()

	if checkOnly {
		check(tempFile, targetFile)
	} else {
		if err := os.Rename(tempFile, targetFile); err != nil {
			log.Fatalf("Failed to rename temp file %s to %s (%v)", tempFile, targetFile, err)
		}
	}
}

func check(tempFile string, targetFile string) {
	tempFileContents, err := os.ReadFile(tempFile)
	if err != nil {
		log.Fatalf("Cannot read temp file %s (%v)", tempFileContents, err)
	}
	fileContents, err := os.ReadFile(targetFile)
	if err != nil {
		log.Fatalf("Cannot read file %s (%v)", targetFile, err)
	}
	if string(fileContents) != string(tempFileContents) {
		log.Fatalf("The %s file does not match the expected contents, please run go generate.", targetFile)
	}
}
